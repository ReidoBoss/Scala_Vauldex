2.4 parameterized class givens

import Printer.{printerln=>println,printer=>print}


class Rational(n: Int, d: Int):
	require(d != 0)
	private val g = gcd(n.abs, d.abs)
	val numer = n / g
	val denom = d / g
	def this(n: Int) = this(n, 1)
	def + (that: Rational): Rational =
		Rational(
			numer * that.denom + that.numer * denom,
			denom * that.denom
		)
	def + (i: Int): Rational =
		Rational(numer + i * denom, denom)
	def - (that: Rational): Rational =
		Rational(
			numer * that.denom - that.numer * denom,
			denom * that.denom
		)
	def - (i: Int): Rational =
		Rational(numer - i * denom, denom)
	def * (that: Rational): Rational =
		Rational(numer * that.numer, denom * that.denom)
	def * (i: Int): Rational =
		Rational(numer * i, denom)
	def / (that: Rational): Rational =
		Rational(numer * that.denom, denom * that.numer)
	def / (i: Int): Rational =
		Rational(numer, denom * i)
	override def toString = s"$numer/$denom"
	private def gcd(a: Int, b: Int): Int = 
		if b == 0 then a else gcd(b, a % b)


trait Ord[T]:
   def compare(x: T, y: T): Int
   def lteq(x: T, y: T): Boolean = compare(x, y) < 1

object Rational:
	given rationalOrd: Ord[Rational] with
		def compare(x: Rational, y: Rational) =
			if x.numer * y.denom < x.denom * y.numer then -1
			else if x.numer * y.denom > x.denom * y.numer then 1
			else 0

def isort[T](xs: List[T])(using ord: Ord[T]): List[T] =
	if xs.isEmpty then Nil
	else insert(xs.head, isort(xs.tail))

def insert[T](x: T, xs: List[T])(using ord: Ord[T]): List[T] =
	if xs.isEmpty || ord.lteq(x, xs.head) then x :: xs
	else xs.head :: insert(x, xs.tail)


@main def stsagarino=
	println(isort(List(Rational(4,5),Rational(1,2),Rational(2,3))))














